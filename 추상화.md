#### 컴파일러와 어셈블러

```c
swap(int v[], int k)
{
  int temp;
  temp = v[k];
  v[k] = v[k+1];
  v[k+1] = temp;
}
```
- 컴파일러 사용
```assembly
swap:
  multi $2, $5,4      # $2 = $5 * 4
  add   $2, $4,$2     # $2 = $4 + $2
  lw    $15, 0($2)    # $15 = memory[$2 + 0] (v[k])
  lw    $16, 4($2)    # $16 = memory[$2 + 4] (v[k+1])
  sw    $16, 0($2)    # memory[$2 + 0] = $16 (v[k] = v[k+1])
  sw    $15, 4($2)    # memory[$2 + 4] = $15 (v[k+1] = v[k])
  jr    $31           # return
```
- 어셈블러 사용  
000000 00101 00000 00010 00010 000000    multi $2, $5, 4  
000000 00000 00010 00010 00000 100000  
000000 00100 00010 00010 00000 100000    add $2, $4, $2  
100011 00010 01111 0000000000000000      lw $15, 0($2)  
100011 00010 10000 0000000000000100      lw $16, 4($2)  
101011 00010 10000 0000000000000000      sw $16, 0($2)  
101011 00010 01111 0000000000000100      sw $15, 4($2)  
000000 11111 00000 00000 00000 001000    jr $31

어셈블러->기계어 번역  
젓 번째 6비트 -> 명령어 (오퍼코드)  
이후 비트 -> 레지스터, 함수 코드, 오프셋 등 (명령어마다 레지스터, 오프셋 등이 다름)  
